import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const ROOT = path.join(__dirname, '..');

const SEED_PATH = path.join(__dirname, 'seeds', 'spells_seed.json');
const CACHE_DIR = path.join(ROOT, '.cache', 'spells');
const OUTPUT_PATH = path.join(ROOT, 'src', 'data', 'spells.ts');

const REFRESH = process.argv.includes('--refresh');

// Ensure directories exist
if (!fs.existsSync(CACHE_DIR)) fs.mkdirSync(CACHE_DIR, { recursive: true });

function safeNumber(v) {
  const n = Number(v);
  return Number.isFinite(n) ? n : 0;
}

function slugify(value) {
  return value
    .normalize('NFKD')
    .replace(/[\u0300-\u036f]/g, '')
    .toLowerCase()
    .replace(/['â€™]/g, '')
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-+|-+$/g, '');
}

async function fetchSpellData(name) {
  const slug = slugify(name);
  const cachePath = path.join(CACHE_DIR, `${slug}.json`);
  
  if (!REFRESH && fs.existsSync(cachePath)) {
    return JSON.parse(fs.readFileSync(cachePath, 'utf-8'));
  }

  try {
    const url = `https://tibiawiki.dev/api/spells/${encodeURIComponent(name)}`;
    const res = await fetch(url);
    if (!res.ok) {
      if (res.status === 404) return null;
      throw new Error(`Failed to fetch ${name}: ${res.status}`);
    }
    
    const data = await res.json();
    fs.writeFileSync(cachePath, JSON.stringify(data, null, 2));
    return data;
  } catch (error) {
    console.error(`Error processing ${name}:`, error.message);
    return null;
  }
}

function parseSpell(raw, name) {
  if (!raw) return null;
  if (typeof raw === 'object' && raw && Object.keys(raw).length === 0) return null;
  const slug = slugify(name);
  
  // Parse vocation
  let vocs = [];
  if (raw.voc) {
    vocs = raw.voc
      .replace(/\[\[|\]\]/g, '') // remove wiki links
      .split(/,|\s+and\s+/) // split by comma or "and"
      .map(v => v.trim().replace(/s$/, '')) // trim and remove plural 's' (Knight -> Knight)
      .filter(v => ['Knight', 'Paladin', 'Sorcerer', 'Druid', 'Elite Knight', 'Royal Paladin', 'Master Sorcerer', 'Elder Druid'].some(cls => v.includes(cls)));
  }

  return {
    id: slug,
    name: raw.name || name,
    words: raw.words || "",
    vocation: vocs.length ? vocs : ['All'],
    type: raw.type || 'Instant',
    cooldown: safeNumber(raw.cooldown) || 2,
    requirement: {
      level: safeNumber(raw.levelrequired),
      magicLevel: 0, // not in API usually
      mana: safeNumber(raw.mana),
      soulPoints: safeNumber(raw.soul),
      premium: raw.premium === 'yes'
    },
    damage: {
      min: 0,
      max: 0,
      element: raw.damagetype ? raw.damagetype.toLowerCase() : 'physical',
      formula: raw.basepower ? `Power: ${raw.basepower}` : undefined
    },
    description: (raw.effect ? raw.effect.replace(/\[\[File:.*?\]\]/g, '').trim() : raw.notes) || "",
    notes: raw.notes
  };
}

async function main() {
  console.log('Starting spells sync...');
  
  if (!fs.existsSync(SEED_PATH)) {
    console.error('Seed file not found. Run fetch-seeds.mjs first.');
    process.exit(1);
  }

  const seed = JSON.parse(fs.readFileSync(SEED_PATH, 'utf-8'));
  console.log(`Loaded ${seed.length} spells from seed.`);

  const spells = [];
  let count = 0;

  for (const name of seed) {
    const raw = await fetchSpellData(name);
    if (raw) {
      const parsed = parseSpell(raw, name);
      if (parsed) spells.push(parsed);
    }
    count++;
    if (count % 20 === 0) process.stdout.write(`\rProcessed ${count}/${seed.length}`);
  }
  
  console.log('\nGenerating output file...');
  
  // Sort spells by name
  spells.sort((a, b) => a.name.localeCompare(b.name));

  const fileContent = `// Generated by scripts/sync-spells.mjs
// Date: ${new Date().toISOString()}

export interface SpellRequirement {
  level: number;
  magicLevel: number;
  mana: number;
  soulPoints?: number;
  premium: boolean;
}

export interface Spell {
  id: string;
  name: string;
  words: string;
  vocation: string[];
  type: string;
  cooldown: number; // seconds
  requirement: SpellRequirement;
  damage?: {
    min: number;
    max: number;
    element: string;
    formula?: string;
  };
  healing?: {
    min: number;
    max: number;
    formula?: string;
  };
  buff?: string;
  description: string;
  pvp?: string;
  notes?: string;
}

export const spells: Spell[] = ${JSON.stringify(spells, null, 2)};
`;

  fs.writeFileSync(OUTPUT_PATH, fileContent);
  console.log(`Saved ${spells.length} spells to ${OUTPUT_PATH}`);
}

main().catch(console.error);
