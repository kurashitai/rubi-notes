import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const ROOT = path.join(__dirname, '..');

const SEED_PATH = path.join(__dirname, 'seeds', 'npcs_seed.json');
const CACHE_DIR = path.join(ROOT, '.cache', 'npcs');
const OUTPUT_PATH = path.join(ROOT, 'src', 'data', 'npcs.ts');

const REFRESH = process.argv.includes('--refresh');
const LIMIT_ARG = process.argv.find((arg) => arg.startsWith('--limit='));
const LIMIT = LIMIT_ARG ? Number(LIMIT_ARG.split('=')[1]) : null;

if (!fs.existsSync(CACHE_DIR)) fs.mkdirSync(CACHE_DIR, { recursive: true });

function slugify(value) {
  return value
    .normalize('NFKD')
    .replace(/[\u0300-\u036f]/g, '')
    .toLowerCase()
    .replace(/['â€™]/g, '')
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-+|-+$/g, '');
}

function safeNumber(v) {
  const n = Number(v);
  return Number.isFinite(n) ? n : 0;
}

async function fetchNpcData(name) {
  const slug = slugify(name);
  const cachePath = path.join(CACHE_DIR, `${slug}.json`);

  if (!REFRESH && fs.existsSync(cachePath)) {
    return JSON.parse(fs.readFileSync(cachePath, 'utf-8'));
  }

  try {
    const url = `https://tibiawiki.dev/api/npcs/${encodeURIComponent(name)}`;
    const res = await fetch(url);
    if (!res.ok) {
      if (res.status === 404) return null;
      throw new Error(`Failed to fetch ${name}: ${res.status}`);
    }

    const data = await res.json();
    fs.writeFileSync(cachePath, JSON.stringify(data, null, 2));
    return data;
  } catch (error) {
    console.error(`Error processing ${name}:`, error.message);
    return null;
  }
}

function parseNpc(raw, name) {
  if (!raw) return null;
  const slug = slugify(name);

  const city = raw.city || raw.town || '';
  const location = raw.location || city || 'Unknown';

  const npc = {
    id: `npc-${slug}`,
    name: raw.name || name,
    location,
    position: {
      x: safeNumber(raw.posx),
      y: safeNumber(raw.posy),
      z: safeNumber(raw.posz),
    },
    town: city || 'Unknown',
    services: [],
    description: raw.job || raw.race || 'NPC',
    notes: raw.notes,
    image: raw.image,
  };

  // Minimal services inference
  if (raw.buysell === 'yes') {
    npc.services.push({ name: 'Trade', type: 'other', notes: 'Buys/Sells (details not parsed yet)' });
  }
  if (raw.bank === 'yes') {
    npc.services.push({ name: 'Bank', type: 'deposit' });
    npc.services.push({ name: 'Bank', type: 'withdraw' });
  }

  return npc;
}

async function main() {
  console.log('Starting npcs sync...');

  if (!fs.existsSync(SEED_PATH)) {
    console.error('Seed file not found. Run fetch-seeds.mjs first.');
    process.exit(1);
  }

  const seed = JSON.parse(fs.readFileSync(SEED_PATH, 'utf-8'));
  const list = LIMIT ? seed.slice(0, LIMIT) : seed;

  console.log(`Loaded ${seed.length} NPCs from seed. Processing ${list.length}...`);

  const npcs = [];
  let count = 0;

  for (const name of list) {
    if (name === '...') continue;
    const raw = await fetchNpcData(name);
    if (raw) {
      const parsed = parseNpc(raw, name);
      if (parsed) npcs.push(parsed);
    }

    count++;
    if (count % 50 === 0) process.stdout.write(`\rProcessed ${count}/${list.length}`);
  }

  console.log('\nGenerating output file...');
  npcs.sort((a, b) => a.name.localeCompare(b.name));

  const fileContent = `// Generated by scripts/sync-npcs.mjs\n// Date: ${new Date().toISOString()}\n\nexport interface NPCService {\n  name: string;\n  type: \"buy\" | \"sell\" | \"quest\" | \"travel\" | \"deposit\" | \"withdraw\" | \"heal\" | \"blessing\" | \"other\";\n  items?: string[];\n  notes?: string;\n}\n\nexport interface NPC {\n  id: string;\n  name: string;\n  location: string;\n  position: { x: number; y: number; z: number };\n  town: string;\n  services: NPCService[];\n  description: string;\n  image?: string;\n  notes?: string;\n}\n\nexport const npcs: NPC[] = ${JSON.stringify(npcs, null, 2)};\n`;

  fs.writeFileSync(OUTPUT_PATH, fileContent);
  console.log(`Saved ${npcs.length} NPCs to ${OUTPUT_PATH}`);
}

main().catch(console.error);
